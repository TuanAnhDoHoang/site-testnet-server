import util from "./nodeUtil.js";
/**
 * The severity level abbreviations.
 */
const levelAbbreviations = {
    "debug": "DBG",
    "info": "INF",
    "warning": "WRN",
    "error": "ERR",
    "fatal": "FTL",
};
/**
 * A platform-specific inspect function.  In Deno, this is {@link Deno.inspect},
 * and in Node.js/Bun it is `util.inspect()`.  If neither is available, it
 * falls back to {@link JSON.stringify}.
 *
 * @param value The value to inspect.
 * @param options The options for inspecting the value.
 *                If `colors` is `true`, the output will be ANSI-colored.
 * @returns The string representation of the value.
 */
const inspect = 
// @ts-ignore: Browser detection
// dnt-shim-ignore
typeof document !== "undefined" ||
    // @ts-ignore: React Native detection
    // dnt-shim-ignore
    typeof navigator !== "undefined" && navigator.product === "ReactNative"
    ? (v) => JSON.stringify(v)
    // @ts-ignore: Deno global
    // dnt-shim-ignore
    : "Deno" in globalThis && "inspect" in globalThis.Deno &&
        // @ts-ignore: Deno global
        // dnt-shim-ignore
        typeof globalThis.Deno.inspect === "function"
        ? (v, opts) => 
        // @ts-ignore: Deno global
        // dnt-shim-ignore
        globalThis.Deno.inspect(v, {
            strAbbreviateSize: Infinity,
            iterableLimit: Infinity,
            ...opts,
        })
        // @ts-ignore: Node.js global
        // dnt-shim-ignore
        : util != null && "inspect" in util && typeof util.inspect === "function"
            ? (v, opts) => 
            // @ts-ignore: Node.js global
            // dnt-shim-ignore
            util.inspect(v, {
                maxArrayLength: Infinity,
                maxStringLength: Infinity,
                ...opts,
            })
            : (v) => JSON.stringify(v);
/**
 * Get a text formatter with the specified options.  Although it's flexible
 * enough to create a custom formatter, if you want more control, you can
 * create a custom formatter that satisfies the {@link TextFormatter} type
 * instead.
 *
 * For more information on the options, see {@link TextFormatterOptions}.
 *
 * By default, the formatter formats log records as follows:
 *
 * ```
 * 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!
 * ```
 * @param options The options for the text formatter.
 * @returns The text formatter.
 * @since 0.6.0
 */
export function getTextFormatter(options = {}) {
    const timestampRenderer = options.timestamp == null || options.timestamp === "date-time-timezone"
        ? (ts) => new Date(ts).toISOString().replace("T", " ").replace("Z", " +00:00")
        : options.timestamp === "date-time-tz"
            ? (ts) => new Date(ts).toISOString().replace("T", " ").replace("Z", " +00")
            : options.timestamp === "date-time"
                ? (ts) => new Date(ts).toISOString().replace("T", " ").replace("Z", "")
                : options.timestamp === "time-timezone"
                    ? (ts) => new Date(ts).toISOString().replace(/.*T/, "").replace("Z", " +00:00")
                    : options.timestamp === "time-tz"
                        ? (ts) => new Date(ts).toISOString().replace(/.*T/, "").replace("Z", " +00")
                        : options.timestamp === "time"
                            ? (ts) => new Date(ts).toISOString().replace(/.*T/, "").replace("Z", "")
                            : options.timestamp === "date"
                                ? (ts) => new Date(ts).toISOString().replace(/T.*/, "")
                                : options.timestamp === "rfc3339"
                                    ? (ts) => new Date(ts).toISOString()
                                    : options.timestamp === "none" || options.timestamp === "disabled"
                                        ? () => null
                                        : options.timestamp;
    const categorySeparator = options.category ?? "·";
    const valueRenderer = options.value ?? inspect;
    const levelRenderer = options.level == null || options.level === "ABBR"
        ? (level) => levelAbbreviations[level]
        : options.level === "abbr"
            ? (level) => levelAbbreviations[level].toLowerCase()
            : options.level === "FULL"
                ? (level) => level.toUpperCase()
                : options.level === "full"
                    ? (level) => level
                    : options.level === "L"
                        ? (level) => level.charAt(0).toUpperCase()
                        : options.level === "l"
                            ? (level) => level.charAt(0)
                            : options.level;
    const formatter = options.format ??
        (({ timestamp, level, category, message }) => `${timestamp ? `${timestamp} ` : ""}[${level}] ${category}: ${message}`);
    return (record) => {
        let message = "";
        for (let i = 0; i < record.message.length; i++) {
            if (i % 2 === 0)
                message += record.message[i];
            else
                message += valueRenderer(record.message[i]);
        }
        const timestamp = timestampRenderer(record.timestamp);
        const level = levelRenderer(record.level);
        const category = typeof categorySeparator === "function"
            ? categorySeparator(record.category)
            : record.category.join(categorySeparator);
        const values = {
            timestamp,
            level,
            category,
            message,
            record,
        };
        return `${formatter(values)}\n`;
    };
}
/**
 * The default text formatter.  This formatter formats log records as follows:
 *
 * ```
 * 2023-11-14 22:13:20.000 +00:00 [INF] category·subcategory: Hello, world!
 * ```
 *
 * @param record The log record to format.
 * @returns The formatted log record.
 */
export const defaultTextFormatter = getTextFormatter();
const RESET = "\x1b[0m";
const ansiColors = {
    black: "\x1b[30m",
    red: "\x1b[31m",
    green: "\x1b[32m",
    yellow: "\x1b[33m",
    blue: "\x1b[34m",
    magenta: "\x1b[35m",
    cyan: "\x1b[36m",
    white: "\x1b[37m",
};
const ansiStyles = {
    bold: "\x1b[1m",
    dim: "\x1b[2m",
    italic: "\x1b[3m",
    underline: "\x1b[4m",
    strikethrough: "\x1b[9m",
};
const defaultLevelColors = {
    debug: "blue",
    info: "green",
    warning: "yellow",
    error: "red",
    fatal: "magenta",
};
/**
 * Get an ANSI color formatter with the specified options.
 *
 * ![A preview of an ANSI color formatter.](https://i.imgur.com/I8LlBUf.png)
 * @param option The options for the ANSI color formatter.
 * @returns The ANSI color formatter.
 * @since 0.6.0
 */
export function getAnsiColorFormatter(options = {}) {
    const format = options.format;
    const timestampStyle = typeof options.timestampStyle === "undefined"
        ? "dim"
        : options.timestampStyle;
    const timestampColor = options.timestampColor ?? null;
    const timestampPrefix = `${timestampStyle == null ? "" : ansiStyles[timestampStyle]}${timestampColor == null ? "" : ansiColors[timestampColor]}`;
    const timestampSuffix = timestampStyle == null && timestampColor == null
        ? ""
        : RESET;
    const levelStyle = typeof options.levelStyle === "undefined"
        ? "bold"
        : options.levelStyle;
    const levelColors = options.levelColors ?? defaultLevelColors;
    const categoryStyle = typeof options.categoryStyle === "undefined"
        ? "dim"
        : options.categoryStyle;
    const categoryColor = options.categoryColor ?? null;
    const categoryPrefix = `${categoryStyle == null ? "" : ansiStyles[categoryStyle]}${categoryColor == null ? "" : ansiColors[categoryColor]}`;
    const categorySuffix = categoryStyle == null && categoryColor == null
        ? ""
        : RESET;
    return getTextFormatter({
        timestamp: "date-time-tz",
        value(value) {
            return inspect(value, { colors: true });
        },
        ...options,
        format({ timestamp, level, category, message, record }) {
            const levelColor = levelColors[record.level];
            timestamp = `${timestampPrefix}${timestamp}${timestampSuffix}`;
            level = `${levelStyle == null ? "" : ansiStyles[levelStyle]}${levelColor == null ? "" : ansiColors[levelColor]}${level}${levelStyle == null && levelColor == null ? "" : RESET}`;
            return format == null
                ? `${timestamp} ${level} ${categoryPrefix}${category}:${categorySuffix} ${message}`
                : format({
                    timestamp,
                    level,
                    category: `${categoryPrefix}${category}${categorySuffix}`,
                    message,
                    record,
                });
        },
    });
}
/**
 * A text formatter that uses ANSI colors to format log records.
 *
 * ![A preview of ansiColorFormatter.](https://i.imgur.com/I8LlBUf.png)
 *
 * @param record The log record to format.
 * @returns The formatted log record.
 * @since 0.5.0
 */
export const ansiColorFormatter = getAnsiColorFormatter();
/**
 * Get a [JSON Lines] formatter with the specified options.  The log records
 * will be rendered as JSON objects, one per line, which is a common format
 * for log files.  This format is also known as Newline-Delimited JSON (NDJSON).
 * It looks like this:
 *
 * ```json
 * {"@timestamp":"2023-11-14T22:13:20.000Z","level":"INFO","message":"Hello, world!","logger":"my.logger","properties":{"key":"value"}}
 * ```
 *
 * [JSON Lines]: https://jsonlines.org/
 * @param options The options for the JSON Lines formatter.
 * @returns The JSON Lines formatter.
 * @since 0.11.0
 */
export function getJsonLinesFormatter(options = {}) {
    let joinCategory;
    if (typeof options.categorySeparator === "function") {
        joinCategory = options.categorySeparator;
    }
    else {
        const separator = options.categorySeparator ?? ".";
        joinCategory = (category) => category.join(separator);
    }
    let getMessage;
    if (options.message === "template") {
        getMessage = (record) => {
            if (typeof record.rawMessage === "string") {
                return record.rawMessage;
            }
            let msg = "";
            for (let i = 0; i < record.rawMessage.length; i++) {
                msg += i % 2 < 1 ? record.rawMessage[i] : "{}";
            }
            return msg;
        };
    }
    else {
        getMessage = (record) => {
            let msg = "";
            for (let i = 0; i < record.message.length; i++) {
                msg += i % 2 < 1
                    ? record.message[i]
                    : JSON.stringify(record.message[i]);
            }
            return msg;
        };
    }
    const propertiesOption = options.properties ?? "nest:properties";
    let getProperties;
    if (propertiesOption === "flatten") {
        getProperties = (properties) => properties;
    }
    else if (propertiesOption.startsWith("prepend:")) {
        const prefix = propertiesOption.substring(8);
        if (prefix === "") {
            throw new TypeError(`Invalid properties option: ${JSON.stringify(propertiesOption)}. It must be of the form "prepend:<prefix>" where <prefix> is a non-empty string.`);
        }
        getProperties = (properties) => {
            const result = {};
            for (const key in properties) {
                result[`${prefix}${key}`] = properties[key];
            }
            return result;
        };
    }
    else if (propertiesOption.startsWith("nest:")) {
        const key = propertiesOption.substring(5);
        getProperties = (properties) => ({ [key]: properties });
    }
    else {
        throw new TypeError(`Invalid properties option: ${JSON.stringify(propertiesOption)}. It must be "flatten", "prepend:<prefix>", or "nest:<key>".`);
    }
    return (record) => {
        return JSON.stringify({
            "@timestamp": new Date(record.timestamp).toISOString(),
            level: record.level === "warning" ? "WARN" : record.level.toUpperCase(),
            message: getMessage(record),
            logger: joinCategory(record.category),
            ...getProperties(record.properties),
        }) + "\n";
    };
}
/**
 * The default [JSON Lines] formatter.  This formatter formats log records
 * as JSON objects, one per line, which is a common format for log files.
 * It looks like this:
 *
 * ```json
 * {"@timestamp":"2023-11-14T22:13:20.000Z","level":"INFO","message":"Hello, world!","logger":"my.logger","properties":{"key":"value"}}
 * ```
 *
 * You can customize the output by passing options to
 * {@link getJsonLinesFormatter}.  For example, you can change the category
 * separator, the message format, and how the properties are formatted.
 *
 * [JSON Lines]: https://jsonlines.org/
 * @since 0.11.0
 */
export const jsonLinesFormatter = getJsonLinesFormatter();
/**
 * The styles for the log level in the console.
 */
const logLevelStyles = {
    "debug": "background-color: gray; color: white;",
    "info": "background-color: white; color: black;",
    "warning": "background-color: orange; color: black;",
    "error": "background-color: red; color: white;",
    "fatal": "background-color: maroon; color: white;",
};
/**
 * The default console formatter.
 *
 * @param record The log record to format.
 * @returns The formatted log record, as an array of arguments for
 *          {@link console.log}.
 */
export function defaultConsoleFormatter(record) {
    let msg = "";
    const values = [];
    for (let i = 0; i < record.message.length; i++) {
        if (i % 2 === 0)
            msg += record.message[i];
        else {
            msg += "%o";
            values.push(record.message[i]);
        }
    }
    const date = new Date(record.timestamp);
    const time = `${date.getUTCHours().toString().padStart(2, "0")}:${date.getUTCMinutes().toString().padStart(2, "0")}:${date.getUTCSeconds().toString().padStart(2, "0")}.${date.getUTCMilliseconds().toString().padStart(3, "0")}`;
    return [
        `%c${time} %c${levelAbbreviations[record.level]}%c %c${record.category.join("\xb7")} %c${msg}`,
        "color: gray;",
        logLevelStyles[record.level],
        "background-color: default;",
        "color: gray;",
        "color: default;",
        ...values,
    ];
}
