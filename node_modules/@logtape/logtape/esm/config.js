import * as dntShim from "./_dnt.shims.js";
import { toFilter } from "./filter.js";
import { LoggerImpl } from "./logger.js";
import { getConsoleSink } from "./sink.js";
/**
 * The current configuration, if any.  Otherwise, `null`.
 */
let currentConfig = null;
/**
 * Strong references to the loggers.
 * This is to prevent the loggers from being garbage collected so that their
 * sinks and filters are not removed.
 */
const strongRefs = new Set();
/**
 * Disposables to dispose when resetting the configuration.
 */
const disposables = new Set();
/**
 * Async disposables to dispose when resetting the configuration.
 */
const asyncDisposables = new Set();
/**
 * Check if a config is for the meta logger.
 */
function isLoggerConfigMeta(cfg) {
    return cfg.category.length === 0 ||
        (cfg.category.length === 1 && cfg.category[0] === "logtape") ||
        (cfg.category.length === 2 &&
            cfg.category[0] === "logtape" &&
            cfg.category[1] === "meta");
}
/**
 * Configure the loggers with the specified configuration.
 *
 * Note that if the given sinks or filters are disposable, they will be
 * disposed when the configuration is reset, or when the process exits.
 *
 * @example
 * ```typescript
 * await configure({
 *   sinks: {
 *     console: getConsoleSink(),
 *   },
 *   filters: {
 *     slow: (log) =>
 *       "duration" in log.properties &&
 *       log.properties.duration as number > 1000,
 *   },
 *   loggers: [
 *     {
 *       category: "my-app",
 *       sinks: ["console"],
 *       level: "info",
 *     },
 *     {
 *       category: ["my-app", "sql"],
 *       filters: ["slow"],
 *       level: "debug",
 *     },
 *     {
 *       category: "logtape",
 *       sinks: ["console"],
 *       level: "error",
 *     },
 *   ],
 * });
 * ```
 *
 * @param config The configuration.
 */
export async function configure(config) {
    if (currentConfig != null && !config.reset) {
        throw new ConfigError("Already configured; if you want to reset, turn on the reset flag.");
    }
    await reset();
    try {
        configureInternal(config, true);
    }
    catch (e) {
        if (e instanceof ConfigError)
            await reset();
        throw e;
    }
}
/**
 * Configure sync loggers with the specified configuration.
 *
 * Note that if the given sinks or filters are disposable, they will be
 * disposed when the configuration is reset, or when the process exits.
 *
 * Also note that passing async sinks or filters will throw. If
 * necessary use {@link resetSync} or {@link disposeSync}.
 *
 * @example
 * ```typescript
 * configureSync({
 *   sinks: {
 *     console: getConsoleSink(),
 *   },
 *   loggers: [
 *     {
 *       category: "my-app",
 *       sinks: ["console"],
 *       level: "info",
 *     },
 *     {
 *       category: "logtape",
 *       sinks: ["console"],
 *       level: "error",
 *     },
 *   ],
 * });
 * ```
 *
 * @param config The configuration.
 * @since 0.9.0
 */
export function configureSync(config) {
    if (currentConfig != null && !config.reset) {
        throw new ConfigError("Already configured; if you want to reset, turn on the reset flag.");
    }
    if (asyncDisposables.size > 0) {
        throw new ConfigError("Previously configured async disposables are still active. " +
            "Use configure() instead or explicitly dispose them using dispose().");
    }
    resetSync();
    try {
        configureInternal(config, false);
    }
    catch (e) {
        if (e instanceof ConfigError)
            resetSync();
        throw e;
    }
}
function configureInternal(config, allowAsync) {
    currentConfig = config;
    let metaConfigured = false;
    let levelUsed = false;
    const configuredCategories = new Set();
    for (const cfg of config.loggers) {
        if (isLoggerConfigMeta(cfg)) {
            metaConfigured = true;
        }
        // Check for duplicate logger categories
        const categoryKey = Array.isArray(cfg.category)
            ? JSON.stringify(cfg.category)
            : JSON.stringify([cfg.category]);
        if (configuredCategories.has(categoryKey)) {
            throw new ConfigError(`Duplicate logger configuration for category: ${categoryKey}. ` +
                `Each category can only be configured once.`);
        }
        configuredCategories.add(categoryKey);
        const logger = LoggerImpl.getLogger(cfg.category);
        for (const sinkId of cfg.sinks ?? []) {
            const sink = config.sinks[sinkId];
            if (!sink) {
                throw new ConfigError(`Sink not found: ${sinkId}.`);
            }
            logger.sinks.push(sink);
        }
        logger.parentSinks = cfg.parentSinks ?? "inherit";
        if (cfg.lowestLevel !== undefined) {
            logger.lowestLevel = cfg.lowestLevel;
        }
        if (cfg.level !== undefined) {
            levelUsed = true;
            logger.filters.push(toFilter(cfg.level));
        }
        for (const filterId of cfg.filters ?? []) {
            const filter = config.filters?.[filterId];
            if (filter === undefined) {
                throw new ConfigError(`Filter not found: ${filterId}.`);
            }
            logger.filters.push(toFilter(filter));
        }
        strongRefs.add(logger);
    }
    LoggerImpl.getLogger().contextLocalStorage = config.contextLocalStorage;
    for (const sink of Object.values(config.sinks)) {
        if (Symbol.asyncDispose in sink) {
            if (allowAsync)
                asyncDisposables.add(sink);
            else {
                throw new ConfigError("Async disposables cannot be used with configureSync().");
            }
        }
        if (Symbol.dispose in sink)
            disposables.add(sink);
    }
    for (const filter of Object.values(config.filters ?? {})) {
        if (filter == null || typeof filter === "string")
            continue;
        if (Symbol.asyncDispose in filter) {
            if (allowAsync)
                asyncDisposables.add(filter);
            else {
                throw new ConfigError("Async disposables cannot be used with configureSync().");
            }
        }
        if (Symbol.dispose in filter)
            disposables.add(filter);
    }
    if ("process" in dntShim.dntGlobalThis && !("Deno" in dntShim.dntGlobalThis)) {
        // @ts-ignore: It's fine to use process in Node
        // deno-lint-ignore no-process-global
        process.on("exit", allowAsync ? dispose : disposeSync);
    }
    else {
        // @ts-ignore: It's fine to addEventListener() on the browser/Deno
        addEventListener("unload", allowAsync ? dispose : disposeSync);
    }
    const meta = LoggerImpl.getLogger(["logtape", "meta"]);
    if (!metaConfigured) {
        meta.sinks.push(getConsoleSink());
    }
    meta.info("LogTape loggers are configured.  Note that LogTape itself uses the meta " +
        "logger, which has category {metaLoggerCategory}.  The meta logger " +
        "purposes to log internal errors such as sink exceptions.  If you " +
        "are seeing this message, the meta logger is automatically configured.  " +
        "It's recommended to configure the meta logger with a separate sink " +
        "so that you can easily notice if logging itself fails or is " +
        "misconfigured.  To turn off this message, configure the meta logger " +
        "with higher log levels than {dismissLevel}.  See also " +
        "<https://logtape.org/manual/categories#meta-logger>.", { metaLoggerCategory: ["logtape", "meta"], dismissLevel: "info" });
    if (levelUsed) {
        meta.warn("The level option is deprecated in favor of lowestLevel option.  " +
            "Please update your configuration.  See also " +
            "<https://logtape.org/manual/levels#configuring-severity-levels>.");
    }
}
/**
 * Get the current configuration, if any.  Otherwise, `null`.
 * @returns The current configuration, if any.  Otherwise, `null`.
 */
export function getConfig() {
    return currentConfig;
}
/**
 * Reset the configuration.  Mostly for testing purposes.
 */
export async function reset() {
    await dispose();
    resetInternal();
}
/**
 * Reset the configuration.  Mostly for testing purposes. Will not clear async
 * sinks, only use with sync sinks. Use {@link reset} if you have async sinks.
 * @since 0.9.0
 */
export function resetSync() {
    disposeSync();
    resetInternal();
}
function resetInternal() {
    const rootLogger = LoggerImpl.getLogger([]);
    rootLogger.resetDescendants();
    delete rootLogger.contextLocalStorage;
    strongRefs.clear();
    currentConfig = null;
}
/**
 * Dispose of the disposables.
 */
export async function dispose() {
    disposeSync();
    const promises = [];
    for (const disposable of asyncDisposables) {
        promises.push(disposable[Symbol.asyncDispose]());
        asyncDisposables.delete(disposable);
    }
    await Promise.all(promises);
}
/**
 * Dispose of the sync disposables. Async disposables will be untouched,
 * use {@link dispose} if you have async sinks.
 * @since 0.9.0
 */
export function disposeSync() {
    for (const disposable of disposables)
        disposable[Symbol.dispose]();
    disposables.clear();
}
/**
 * A configuration error.
 */
export class ConfigError extends Error {
    /**
     * Constructs a new configuration error.
     * @param message The error message.
     */
    constructor(message) {
        super(message);
        this.name = "ConfigureError";
    }
}
