"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withFilter = withFilter;
exports.getStreamSink = getStreamSink;
exports.getConsoleSink = getConsoleSink;
const filter_js_1 = require("./filter.js");
const formatter_js_1 = require("./formatter.js");
/**
 * Turns a sink into a filtered sink.  The returned sink only logs records that
 * pass the filter.
 *
 * @example Filter a console sink to only log records with the info level
 * ```typescript
 * const sink = withFilter(getConsoleSink(), "info");
 * ```
 *
 * @param sink A sink to be filtered.
 * @param filter A filter to apply to the sink.  It can be either a filter
 *               function or a {@link LogLevel} string.
 * @returns A sink that only logs records that pass the filter.
 */
function withFilter(sink, filter) {
    const filterFunc = (0, filter_js_1.toFilter)(filter);
    return (record) => {
        if (filterFunc(record))
            sink(record);
    };
}
/**
 * A factory that returns a sink that writes to a {@link WritableStream}.
 *
 * Note that the `stream` is of Web Streams API, which is different from
 * Node.js streams.  You can convert a Node.js stream to a Web Streams API
 * stream using [`stream.Writable.toWeb()`] method.
 *
 * [`stream.Writable.toWeb()`]: https://nodejs.org/api/stream.html#streamwritabletowebstreamwritable
 *
 * @example Sink to the standard error in Deno
 * ```typescript
 * const stderrSink = getStreamSink(Deno.stderr.writable);
 * ```
 *
 * @example Sink to the standard error in Node.js
 * ```typescript
 * import stream from "node:stream";
 * const stderrSink = getStreamSink(stream.Writable.toWeb(process.stderr));
 * ```
 *
 * @param stream The stream to write to.
 * @param options The options for the sink.
 * @returns A sink that writes to the stream.
 */
function getStreamSink(stream, options = {}) {
    const formatter = options.formatter ?? formatter_js_1.defaultTextFormatter;
    const encoder = options.encoder ?? new TextEncoder();
    const writer = stream.getWriter();
    let lastPromise = Promise.resolve();
    const sink = (record) => {
        const bytes = encoder.encode(formatter(record));
        lastPromise = lastPromise
            .then(() => writer.ready)
            .then(() => writer.write(bytes));
    };
    sink[Symbol.asyncDispose] = async () => {
        await lastPromise;
        await writer.close();
    };
    return sink;
}
/**
 * A console sink factory that returns a sink that logs to the console.
 *
 * @param options The options for the sink.
 * @returns A sink that logs to the console.
 */
function getConsoleSink(options = {}) {
    const formatter = options.formatter ?? formatter_js_1.defaultConsoleFormatter;
    const levelMap = {
        debug: "debug",
        info: "info",
        warning: "warn",
        error: "error",
        fatal: "error",
        ...(options.levelMap ?? {}),
    };
    const console = options.console ?? globalThis.console;
    return (record) => {
        const args = formatter(record);
        const method = levelMap[record.level];
        if (method === undefined) {
            throw new TypeError(`Invalid log level: ${record.level}.`);
        }
        if (typeof args === "string") {
            const msg = args.replace(/\r?\n$/, "");
            console[method](msg);
        }
        else {
            console[method](...args);
        }
    };
}
